//
// Copyright(C) 2023 Brian Koropoff
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// DESCRIPTION:
//	BSP Analysis
//

#include <assert.h>
#include <math.h>

#include "bsp.h"
#include "dgeom.h"
#include "lprintf.h"
#include "r_state.h"
#include "z_zone.h"
#include "m_bbox.h"
#include "gl_struct.h"

// Path through the BSP tree
struct bsp_path
{
  node_t* node;
  dside_t side;
  dline_t div;
  struct bsp_path* up;
  struct bsp_path* down;
};

// Point with associated epsilon, used for building polygon out of a pile of
// segments
typedef struct epoint_s
{
  dpoint_t p;
  dfixed_t epsilon;
} epoint_t;

// Implicit segments generated by BSP divisions
iseg_t* isegs = NULL;
unsigned int numisegs = 0;
unsigned int capisegs = 0;

// Adjacency graph edges
int* adjacency = NULL;
unsigned int numadjacency = 0;
unsigned int capadjacency = 0;

// Bounding box of current map
fixed_t mapbox[4];

static dboolean annotated = false;

static void PathInit(struct bsp_path* path, node_t* node, struct bsp_path* up)
{
  node->isegs = NO_ISEG;

  path->node = node;
  path->up = up;
  if (up)
    up->down = path;
  path->down = NULL;

  path->div = dgeom_DLineFromNode(node);
  dgeom_ClipLineByBox(&path->div, mapbox, &path->div);
}

// Return div line oriented according to side being visited
static inline dline_t PathDiv(const struct bsp_path* path)
{
  if (path->side == DGEOM_SIDE_LEFT)
  {
    dline_t r = {path->div.end, path->div.start};
    return r;
  }
  return path->div;
}

//
// Pass 1: implicit segment computation
//

// Pass 1b: with implicit segments in hand, mark segs as orphaned if some (later)
// implicit segment overlaps them, as they aren't needed to build a bounding
// polygon for the subsector
static void SubsumeSegs(subsector_t* subsector)
{
  int i, j;

  for (i = 0; i < subsector->numlines; ++i)
  {
    seg_t* seg = &segs[subsector->firstline + i];
    // Use seg line to test coincidence, not seg!  Segs get rounded off during
    // node building.
    dline_t l1 = dgeom_DLineFromSegLine(seg);
    for (j = 0; j < subsector->numisegs; ++j)
    {
      iseg_t* iseg = &isegs[subsector->firstiseg + j];
      dline_t l2 = dgeom_DLineFromISeg(iseg);
      if (dgeom_LinesCoincide(&l2, &l1, dgeom_epsilonr2))
      {
        seg->flags |= SEGF_ORPHAN;
        break;
      }
    }
  }

  for (i = 0; i < subsector->numisegs; ++i)
  {
    iseg_t* iseg = &isegs[subsector->firstiseg + i];
    dline_t l1 = dgeom_DLineFromISeg(iseg);
    for (j = i + 1; j < subsector->numisegs; ++j)
    {
      dline_t l2 = dgeom_DLineFromISeg(&isegs[subsector->firstiseg + j]);
      if (dgeom_LinesCoincide(&l2, &l1, dgeom_epsilonr2))
      {
        iseg->flags |= SEGF_ORPHAN;
        break;
      }
    }
  }
}

// Pass 1c: with implicit segments in hand and duplicate segments marked,
// find the bounding polygon of a subsector

// Mark seg/iseg and return next point in bounding polygon for subsector
static dboolean MarkNext(subsector_t* subsector, dboolean start,
                         dboolean strict, epoint_t* p)
{
  int i;

  for (i = 0; i < subsector->numlines; ++i)
  {
    seg_t* seg = &segs[subsector->firstline + i];
    dpoint_t v1;

    if (seg->flags & (SEGF_ORPHAN | SEGF_CYCLIC | SEGF_MARK))
      continue;

    v1 = dgeom_DPointFromVertex(seg->v1);

    if (start)
    {
      p->p = v1;
      p->epsilon = dgeom_epsilonmapr2;
      return true;
    }

    if (dgeom_PointsEqual(&p->p, &v1, strict ? dgeom_epsilon : dgeom_epsilonmapr2))
    {
      seg->flags |= SEGF_MARK;
      p->p = dgeom_DPointFromVertex(seg->v2);
      p->epsilon = dgeom_epsilonmapr2;
      return true;
    }
  }

  for (i = 0; i < subsector->numisegs; ++i)
  {
    iseg_t* seg = &isegs[subsector->firstiseg + i];
    dpoint_t v1;

    if (seg->flags & (SEGF_ORPHAN | SEGF_CYCLIC | SEGF_MARK))
      continue;

    v1.x = seg->x1;
    v1.y = seg->y1;

    if (start)
    {
      p->p = v1;
      p->epsilon = dgeom_epsilon;
      return true;
    }

    if (dgeom_PointsEqual(&p->p, &v1, strict ? dgeom_epsilon : fmax(dgeom_epsilon, p->epsilon)))
    {
      seg->flags |= SEGF_MARK;
      p->p.x = seg->x2;
      p->p.y = seg->y2;
      p->epsilon = dgeom_epsilon;
      return true;
    }
  }

  return false;
}

// Clear marked segs/isegs, setting orphan/cyclic as appropriate
static void ClearMarks(subsector_t* subsector, dboolean cycle_found)
{
  int i;

  for (i = 0; i < subsector->numlines; ++i)
  {
    seg_t* seg = &segs[subsector->firstline + i];
    if (seg->flags & SEGF_MARK)
    {
      if (cycle_found)
        seg->flags |= SEGF_CYCLIC;
      else
        seg->flags |= SEGF_ORPHAN;
    }
    seg->flags &= ~SEGF_MARK;
  }

  for (i = 0; i < subsector->numisegs; ++i)
  {
    iseg_t* seg = &isegs[subsector->firstiseg + i];
    if (seg->flags & SEGF_MARK)
    {
      if (cycle_found)
        seg->flags |= SEGF_CYCLIC;
      else
        seg->flags |= SEGF_ORPHAN;
    }
    seg->flags &= ~SEGF_MARK;
  }
}

// Finds cyclic segs (i.e. the bounding polygon) of the subsector. This is only
// for detecting (and avoiding) degenerate subsectors that some node builders
// produce, but it could eventually replace the triangulation code in
// gl_preprocess.
static dboolean MarkCyclicSegs(subsector_t* subsector)
{
  int i;
  dboolean found = false;
  epoint_t start, p;
  dboolean cycle;

  while (MarkNext(subsector, true, false, &start))
  {
    p = start;
    cycle = false;
    while (MarkNext(subsector, false, true, &p) ||
           MarkNext(subsector, false, false, &p))
    {
      if (dgeom_PointsEqual(&start.p, &p.p, fmax(start.epsilon, p.epsilon)))
      {
        cycle = found = true;
        break;
      }
    }

    ClearMarks(subsector, cycle);
  }

  return found;
}

// Pass 1a: find implicit segments by traversing BSP tree and clipping partition lines

static void PushISeg(subsector_t* subsector, node_t* node, const dline_t* dseg)
{
  iseg_t* iseg;

  if (numisegs == capisegs)
  {
    if (capisegs == 0)
      capisegs = 256;
    else
      capisegs *= 2;
    isegs = Z_Realloc(isegs, sizeof(*isegs) * capisegs);
    if (!isegs)
      I_Error("Could not allocate memory for isegs");
  }

  iseg = &isegs[numisegs++];
  iseg->x1 = dgeom_DFixedToFixed(dseg->start.x);
  iseg->y1 = dgeom_DFixedToFixed(dseg->start.y);
  iseg->x2 = dgeom_DFixedToFixed(dseg->end.x);
  iseg->y2 = dgeom_DFixedToFixed(dseg->end.y);
  iseg->nodenum = node - nodes;
  iseg->subsector = subsector;
  iseg->firstadjacent = 0;
  iseg->numadjacent = 0;
  iseg->next = node->isegs;
  node->isegs = iseg - isegs;
  ++subsector->numisegs;
}

// Annotate implicit segs of a subsector (base case of traversal)
static void AnnotateSubsectorISegs(struct bsp_path* path,
                                   subsector_t* subsector)
{
  struct bsp_path* cur;
  struct bsp_path* clip;
  int i, j;

  subsector->firstiseg = numisegs;
  subsector->numisegs = 0;

  // Clip all BSP division lines by all others on this path and all segs in the
  // subsector
  for (cur = path; cur != NULL; cur = cur->up)
  {
    dline_t candidate = PathDiv(cur);
    dboolean discard = false;

    for (i = 0; i < subsector->numlines; ++i)
    {
      seg_t* seg = &segs[subsector->firstline + i];
      // Use original linedef, not seg!  Segs are rounded to the nearest whole
      // map unit during node building and can be significantly skewed.
      dline_t dseg = dgeom_DLineFromSegLine(seg);

      if ((discard = dgeom_ClipSegmentByLine(&candidate, &dseg, DGEOM_SIDE_RIGHT)))
        break;
    }

    if (discard)
      continue;

    for (clip = path; clip; clip = clip->up)
    {
      if (clip == cur)
        continue;

      if ((discard = dgeom_ClipSegmentByLine(&candidate, &clip->div, clip->side)))
        break;
    }

    if (discard)
      continue;

    // We have a new segment
    PushISeg(subsector, cur->node, &candidate);
  }

  // Mark duplicate segs/isegs
  SubsumeSegs(subsector);

  // Mark segs that are part of bounding polygon, and mark subsector as
  // degenerate if it can't form one.
  if (!MarkCyclicSegs(subsector))
    subsector->flags |= SUBF_DEGENERATE;
}

// Recursively annotate implicit segments
static void AnnotateISegs(struct bsp_path* start, struct bsp_path* path)
{
  struct bsp_path next;
  dside_t side;
  int i;

  for (side = DGEOM_SIDE_RIGHT; side <= DGEOM_SIDE_LEFT; ++side)
  {
    int child = path->node->children[side];
    fixed_t* bbox = path->node->bbox[side];

    path->side = side;

    if (child & NF_SUBSECTOR)
    {
      subsector_t* subsector = &subsectors[child & ~NF_SUBSECTOR];

      // Base case, generate isegs for this subsector
      AnnotateSubsectorISegs(path, subsector);

      // Fix bounding box to include isegs
      for (i = 0; i < subsector->numisegs; ++i)
      {
        iseg_t* iseg = &isegs[subsector->firstiseg + i];

        M_AddToBox(bbox, iseg->x1, iseg->y1);
        M_AddToBox(bbox, iseg->x2, iseg->y2);
      }
    }
    else
    {
      fixed_t* ibbox;

      // Recurse down this side
      PathInit(&next, &nodes[child], path);
      AnnotateISegs(start, &next);

      // Propagate bounding box fixes
      ibbox = next.node->bbox[DGEOM_SIDE_RIGHT];
      M_AddToBox(bbox, ibbox[BOXLEFT], ibbox[BOXBOTTOM]);
      M_AddToBox(bbox, ibbox[BOXRIGHT], ibbox[BOXTOP]);
      ibbox = next.node->bbox[DGEOM_SIDE_LEFT];
      M_AddToBox(bbox, ibbox[BOXLEFT], ibbox[BOXBOTTOM]);
      M_AddToBox(bbox, ibbox[BOXRIGHT], ibbox[BOXTOP]);
    }
  }

  path->down = NULL;
}

// Annotate all implicit segments: subsector bounds generated by a division line
// in the BSP tree.
void AnnotateImplicitSegs(void)
{
  struct bsp_path root;
  node_t* top;

  if (numnodes == 0)
    return;

  top = &nodes[numnodes - 1];

  // Compute map bounds
  M_ClearBox(mapbox);
  M_AddToBox(mapbox, top->bbox[0][BOXLEFT], top->bbox[0][BOXBOTTOM]);
  M_AddToBox(mapbox, top->bbox[0][BOXRIGHT], top->bbox[0][BOXTOP]);
  M_AddToBox(mapbox, top->bbox[1][BOXLEFT], top->bbox[1][BOXBOTTOM]);
  M_AddToBox(mapbox, top->bbox[1][BOXRIGHT], top->bbox[1][BOXTOP]);

  PathInit(&root, &nodes[numnodes - 1], NULL);
  AnnotateISegs(&root, &root);
}

// Pass 2: compute adjacent subsectors, detect "funny" segs

static void PushAdjacency(int id)
{
  if (numadjacency == capadjacency)
  {
    if (capadjacency == 0)
      capadjacency = 256;
    else
      capadjacency *= 2;
    adjacency = Z_Realloc(adjacency, sizeof(*adjacency) * capadjacency);
    if (!adjacency)
      I_Error("Could not allocate memory for adjacency");
  }
  adjacency[numadjacency++] = id;
}

static void AddSegAdjacent(seg_t* seg, subsector_t* adj)
{
  int i;
  int id = adj - subsectors;

  // Check for duplicate
  for (i = 0; i < seg->numadjacent; ++i)
  {
    if (adjacency[seg->firstadjacent + i] == id)
      return;
  }
  PushAdjacency(id);
  seg->numadjacent++;
}

static void AddISegAdjacent(iseg_t* iseg, subsector_t* adj)
{
  int i;
  int id = adj - subsectors;

  // Check for duplicate
  for (i = 0; i < iseg->numadjacent; ++i)
  {
    if (adjacency[iseg->firstadjacent + i] == id)
      return;
  }
  PushAdjacency(id);
  iseg->numadjacent++;
}

// Find the implicit segments adjacent to this one by consulting the list
// attached to the node which generated it.  Faster and more accurate than
// a BSP traversal, as has to be done for segs.
static void FindAdjacentISegs(iseg_t* seg)
{
  node_t* node = &nodes[seg->nodenum];
  dline_t dseg = dgeom_DLineFromISeg(seg);
  dline_t oseg, eseg;
  iseg_t* cur;

  for (cur = dsda_ISeg(node->isegs); cur; cur = dsda_ISeg(cur->next))
  {
    if (cur->subsector == seg->subsector)
      continue;

    oseg = dgeom_DLineFromISeg(cur);

    // Don't pick an iseg on the same side
    if (dgeom_ParallelLinesHaveSameOrientation(&oseg, &dseg))
      continue;

    // Make sure isegs overlap
    if (dgeom_CounterOrientedCoincidentSegmentsOverlap(&oseg, &dseg, dgeom_epsilonr2))
      AddISegAdjacent(seg, cur->subsector);
  }
}

// Seg-seg adjacency
static dboolean TestAdjacentSegs(const seg_t* seg, const seg_t* oseg)
{
  dline_t line, oline;
  dline_t dseg, odseg;
  dpoint_t p;

  if (seg->subsector == oseg->subsector)
    return false;

  // Test linedefs first, as linedefs don't get rounded off to map units
  line = dgeom_DLineFromSegLine(seg);
  oline = dgeom_DLineFromSegLine(oseg);

  if (!dgeom_LinesCoincide(&line, &oline, dgeom_epsilonr2))
    return false;

  dseg = dgeom_DLineFromSeg(seg);
  odseg = dgeom_DLineFromSeg(oseg);

  return dgeom_CoincidentSegmentsOverlap(&dseg, &odseg, dgeom_epsilonr2);
}

// Seg-iseg adjacency
static dboolean TestAdjacentSegISeg(const seg_t* seg, const iseg_t* oseg)
{
  dline_t line;
  dline_t dseg, odseg;
  dpoint_t p;

  if (seg->subsector == oseg->subsector)
    return false;

  // Test linedef first, as linedefs don't get rounded off to map units
  line = dgeom_DLineFromSegLine(seg);
  odseg = dgeom_DLineFromISeg(oseg);

  if (!dgeom_LinesCoincide(&line, &odseg, dgeom_epsilonr2))
    return false;

  dseg = dgeom_DLineFromSeg(seg);

  return dgeom_CoincidentSegmentsOverlap(&dseg, &odseg, dgeom_epsilonr2);
}

// Recursively search for subsectors adjacent to `seg`.
static void FindAdjacentSegs(seg_t* seg, int nodenum)
{
  dside_t side;
  const node_t* node;
  subsector_t* other;
  int i;
  // FIXME: maybe move this calculation out of this function
  // and make caller pass it.  Probably not worth it.
  dpoint_t mid = {(seg->v1->x + seg->v2->x) / 2, (seg->v1->y + seg->v2->y) / 2};

  if (numnodes == 0)
    return;

  if (nodenum & NF_SUBSECTOR)
  {
    // Base case
    other = &subsectors[nodenum & ~NF_SUBSECTOR];

    for (i = 0; i < other->numlines; ++i)
    {
      const seg_t* oseg = &segs[other->firstline + i];

      if (TestAdjacentSegs(seg, oseg))
        AddSegAdjacent(seg, other);
    }

    for (i = 0; i < other->numisegs; ++i)
    {
      const iseg_t* oseg = &isegs[other->firstiseg + i];

      if (TestAdjacentSegISeg(seg, oseg))
        AddSegAdjacent(seg, other);
    }
    return;
  }

  node = &nodes[nodenum];

  // Recursively search both children if we are too close to the division line to
  // make a call
  for (side = DGEOM_SIDE_RIGHT; side <= DGEOM_SIDE_LEFT; ++side)
  {
    dline_t div = dgeom_DLineFromNode(node);

    if (dgeom_PointIsOnSide(&mid, &div, side, dgeom_epsilonr2))
        FindAdjacentSegs(seg, node->children[side]);
  }
}

static void AnnotateSubsectorAdjacency(subsector_t* subsector, subsector_t** queue)
{
  int i, j, k;
  seg_t* suspicious_seg = NULL;

  // Mark ordinary adjacent sectors for later
  for (i = 0; i < subsector->sector->linecount; ++i)
  {
    line_t* l = subsector->sector->lines[i];

    if (l->frontsector && l->frontsector != subsector->sector)
      l->frontsector->flags |= SECTOR_MARK;
    if (l->backsector && l->backsector != subsector->sector)
      l->backsector->flags |= SECTOR_MARK;
  }

  for (i = 0; i < subsector->numlines; ++i)
  {
    seg_t* seg = &segs[subsector->firstline + i];

    seg->firstadjacent = numadjacency;
    FindAdjacentSegs(seg, numnodes - 1);

    if (seg->frontsector != seg->backsector)
      continue;

    // Look for obvious fake segment
    for (j = 0; j < seg->numadjacent; ++j)
    {
      subsector_t* adj = &subsectors[adjacency[seg->firstadjacent + j]];

      // An adjacent sector that contradicts the sidedef?
      if (adj->sector != seg->backsector)
      {
        // https://www.youtube.com/watch?v=H6yQOs93Cgg
        seg->flags |= SEGF_FAKE;

        if (!(subsector->flags & SUBF_FAKE))
        {
          subsector->flags |= SUBF_FAKE;
          subsector->q_next = *queue;
          *queue = subsector;
        }

        break;
      }
    }

    // I've got my eye on you
    if (!suspicious_seg && !(subsector->flags & SUBF_FAKE))
    {
      suspicious_seg = seg;
      // Leave space for an extra adjacency
      PushAdjacency(-1);
    }
  }

  for (i = 0; i < subsector->numisegs; ++i)
  {
    iseg_t* iseg = &isegs[subsector->firstiseg + i];

    iseg->firstadjacent = numadjacency;
    FindAdjacentISegs(iseg);

    if (!suspicious_seg)
      continue;

    // Try to detect more subtle fake segment
    for (j = 0; j < iseg->numadjacent; ++j)
    {
      subsector_t* adj = &subsectors[adjacency[iseg->firstadjacent + j]];

      // If sector is reachable normally or subsector is well-formed, keep looking
      if (adj->sector->flags & SECTOR_MARK || !(adj->flags & SUBF_DEGENERATE))
        continue;

      // On the one hand, we have a self-referencing seg. On the other, we
      // reached a bogus subsector of a sector we supposedly aren't adjacent to.
      // Convict on circumstantial evidence.
      // FIXME: I'm not super happy with this logic, but without rebuilding
      // the BSP tree, we have to make sense of the mangled pile of cursed
      // geometry old node builders spit out.
      suspicious_seg->flags |= SEGF_FAKE;
      adjacency[suspicious_seg->firstadjacent + suspicious_seg->numadjacent] =
          adj - subsectors;
      suspicious_seg->numadjacent++;
      suspicious_seg = NULL;

      if (!(subsector->flags & SUBF_FAKE))
      {
        subsector->flags |= SUBF_FAKE;
        subsector->q_next = *queue;
        *queue = subsector;
      }

      break;
    }
  }

  // Clear our marks
  for (i = 0; i < subsector->sector->linecount; ++i)
  {
    line_t* l = subsector->sector->lines[i];

    if (l->frontsector && l->frontsector != subsector->sector)
      l->frontsector->flags &= ~SECTOR_MARK;
    if (l->backsector && l->backsector != subsector->sector)
      l->backsector->flags &= ~SECTOR_MARK;
  }
}

// Annotate all subsector segs/isegs with adjacent subsector. Also detect fake
// segs/subsectors.
static void AnnotateAdjacency(void)
{
  int i, j;
  subsector_t* queue = NULL;
  subsector_t* cur;

  for (i = 0; i < numsubsectors; ++i)
    AnnotateSubsectorAdjacency(&subsectors[i], &queue);

  // Process subsectors that need the fake flag spread to neighbors
  while (queue)
  {
    cur = queue;
    queue = queue->q_next;

    for (i = 0; i < cur->numlines; ++i)
    {
      seg_t* seg = &segs[cur->firstline + i];

      for (j = 0; j < seg->numadjacent; ++j)
      {
        subsector_t* adj = &subsectors[adjacency[seg->firstadjacent + j]];

        if (adj->sector == cur->sector && !(adj->flags & SUBF_FAKE))
        {
          adj->flags |= SUBF_FAKE;
          adj->q_next = cur;
          queue = adj;
        }
      }
    }

    for (i = 0; i < cur->numisegs; ++i)
    {
      iseg_t* iseg = &isegs[cur->firstiseg + i];

      for (j = 0; j < iseg->numadjacent; ++j)
      {
        subsector_t* adj = &subsectors[adjacency[iseg->firstadjacent + j]];

        if (adj->sector == cur->sector && !(adj->flags & SUBF_FAKE))
        {
          adj->flags |= SUBF_FAKE;
          adj->q_next = cur;
          queue = adj;
        }
      }
    }
  }
}

// Pass 0: make all segs point at their subsectors for later passes
// FIXME: should p_setup just do this all the time?
static void AnnotateSegSubsectors(void)
{
  int i, j;
  subsector_t* sub;
  seg_t* s;

  for (i = 0; i < numsubsectors; ++i)
  {
    sub = &subsectors[i];
    for (j = 0; j < sub->numlines; ++j)
    {
      s = &segs[sub->firstline + j];
      s->subsector = sub;
    }
  }
}

//
// Public interface
//

void dsda_AnnotateBSP(void)
{
  if (!annotated)
  {
    AnnotateSegSubsectors();
    if (!use_gl_nodes)
      AnnotateImplicitSegs();
    AnnotateAdjacency();
    annotated = true;
  }
}

void dsda_ClearBSP(void)
{
  numisegs = 0;
  capisegs = 0;
  if (isegs)
    Z_Free(isegs);
  isegs = NULL;

  numadjacency = 0;
  capadjacency = 0;
  if (adjacency)
    Z_Free(adjacency);
  adjacency = NULL;

  annotated = false;
}
